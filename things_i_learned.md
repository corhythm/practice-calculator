# 하면서 배운 것들

---

## 입력버퍼에 계속 문자열 남아 있는 문제

1. 정수 입력받을 때, `scanner.nextInt()`로 대기중인데 문자를 입력받으면 `InputMismatchException` 예외가 발생.
2. 예외가 발생해도, 입력 버퍼에는 잘못 입력한 문자 혹은 문자열이 있는 상태임.
3. 다음에 다른 입력을 대기해도 기존에 입력 버퍼에 대기하던 문자들이 우선적으로 방출됨.
4. 잘못된 시나리오로 로직이 전개 됨.
5. 그러니 입력 버퍼 비워줘야 함.
6. 버퍼에 해당 값이 담겨 있다는 걸 몰랐음.
7. `nextLine();`사용해 버퍼를 비워주면 깔끔함.

## IEEE754 (feat. 부동소수점)

1. 부동소수점은 실수를 근사적으로 표현하기 위해 사용되는 수치 표현 방식임.
2. 말이 어려움.
3. `123.456`같이 고정된 소수점의 경우, 정수 2자리, 소수 2자리만 저장할 수 있도록 설정되어 있다면 해당 수는 표현이 제한됨.
4. 실수 중에는 끝이 없는 실수 `π(3.1415926535…)`가 그러함.
5. 그렇기에 어느 지점에서는 값을 끊어야 함. 고정소수점 방식의 한계임.
6. 부동소수점은 소수점 위치를 이동시켜, 더 넓은 범위와 더 정밀한 값을 커버하기 위해 사용되는 표현 방식임.
7. 그리고 이 부동소수점의 대표격이 바로 IEEE754 방식임.
8. 자바에서 소수 표현 타입 크게 `float`와 `double`이 있음.
9. 두 타입 모두 부동소수점 방식을 사용하지만 차이점은 표현할 수 있는 크기의 차이임. 나머지는 동일함.
10. `float`은 부호(1bit) / 지수부(8bits) / 가수부(23bits)로 구성되어 있고, `double`은 부호(1bit) / 지수부(11bits) / 가수부 (52bits)로 구성되어 있음.
11. 부호는 말 그대로 +/- 부호를 나타냄. 0(양수), 1(음수)
12. 예를 들어 보겠음.
13. `12.375`라는 값이 있으면, 이것을 이진수로 변환해야 함. (변환하는 법 찾아볼 것)
14. 변환하면 1100.011(2)가 나옴.
15. 소수점을 맨 앞자리 전까지 당김. -> 1.100011(2) x 2^3
16. 여기수 지수부가 3 + Bias, 가수부가 맨 앞 1을 제외한 100011임.
17. Bias라는 값이 있음. 부동소수점 표현에서 지수부(Exponent)값을 양수로 표현하기 위한 기준값임.
18. 말이 어려움.
19. 0.00123은 -> 1.23 x 10^-3으로 표현됨
20. 컴퓨터는 음수를 좋아하지 않음. 그렇기에 지수부 값을 항상 양수로 저장하기 위해 Bias라는 기준값을 더함.
21. 컴퓨터에서 음의 정수를 표현하기 위해 보수를 고안한 것과 비슷하다고 생각하면 됨.
22. 여튼 `float`의 Bias 값은 127(2^7 - 1)이고 `double`의 Bias 값은 1023(2^10 - 1)임.
23. (참고로 `float`의 지수부 표현 범위는 8비트(-127 ~ 128)이고 `double`은 11비트(-1022 ~ 1023)임)
24. 다시 계산으로 돌아가겠음. `float` 기준임.
25. 12.375 -> 1100.011(2) -> 2^3 x 1.100011(2) -> 127 + 3 == 130 -> (지수부 130을 8비트로 표현) -> 1000 0010(2)
26. 부호(양): 0 / 지수부: 10000010(2) / 가수부: 10001100000000000000000 (나머지는 0으로 채움)
27. -> '0' '10000010' '100011'00000000000000000

## BigDecimal

1. 제네릭으로 처리하는 방법이 어려워 찾아보니, `BigDecimal`이라는 게 있음. 요놈 실행 방식이 재밌음.
2. 이 친구는 소수와 정수 모두를 저장할 수 있으며 소수 + 정수 역시 별도의 형변환 없이 저장된다고 함.
3. 보통 소수를 저장할 때는 IEEE754 부동소수점 방식으로 저장이 되어, 소수 그 자체 값이 아닌 근사치에 가까운 값이 저장됨.
4. 그러니 소수와 관련된 연산을 할 때는 상대적으로 부정확한 값이 저장될 수밖에 없는데 BigDecimal은 정확한 연산을 제공해 금융공학 같은 엄밀한 값이 보장되는 분야에서도 사용됨.
5. 연산 방법은 다음과 같음.
6. `BigDecimal num = new BigDecimal("12.5);`와 같이 문자열로 초기화.
7. 이때 초기화 값으로 문자열이 아닌 정수나 소수 자체를 입력할 수도 있는데 소수를 입력할 경우에는 부정확한 값으로 초기화될 가능성이 있음.
8. 문자열을 정수나 소수로 초기화할 때 scale를 이용해 정수부분과 가수부분을 기억.
9. 이를테면, "12.5"면 125(scale 1), "10" -> 10(scale 0)
10. 위 두 값을 더하면 123 + 10 -> 133 -> scale(1 + 0) 적용을 해서 13.3이 됨.
11. 이런 식으로 연산을 하기에 소수점 손실 없이 정확한 계산이 가능.

## BigInteger

1. 보통 `Byte`, `Short`, `Integer`, `Long` 타입들은 메모리가 한정돼, 표현할 수 있느 숫자 범위가 정해져 있음.
2. 그런데 `BigInteger`는 매우 큰 숫자도 무리 없이 다룰 수 있는데 그 이유가 필요에 따라 동적으로 할당하기 때문에 매우 큰 정수를 저장할 수 있음.
3. 즉, 저장 가능한 값의 크기는 사용 가능한 힙 메모리에 따라 결정.
4. 그러니 다른 고정된 정수 타입과 달리 `BigInteger`는 값의 크기에 제한이 없기에 정수 타입에서 볼 수 있는 정밀도 손실이나 오버플로우 문제가 없음
5. 단, 고정 크기 정수보다 연산 속도는 느림. 그러나 안정적임.

# Covariance & ContraVariance (feat. Wildcard)


