# 하면서 배운 것들

---

## 입력버퍼에 계속 문자열 남아 있는 문제

1. 정수 입력받을 때, `scanner.nextInt()`로 대기중인데 문자를 입력받으면 `InputMismatchException` 예외가 발생.
2. 예외가 발생해도, 입력 버퍼에는 잘못 입력한 문자 혹은 문자열이 있는 상태임.
3. 다음에 다른 입력을 대기해도 기존에 입력 버퍼에 대기하던 문자들이 우선적으로 방출됨.
4. 잘못된 시나리오로 로직이 전개 됨.
5. 그러니 입력 버퍼 비워줘야 함.
6. 버퍼에 해당 값이 담겨 있다는 걸 몰랐음.
7. `nextLine();`사용해 버퍼를 비워주면 깔끔함.

## IEEE754 (feat. 부동소수점)

1. 부동소수점은 실수를 근사적으로 표현하기 위해 사용되는 수치 표현 방식임.
2. 말이 어려움.
3. `123.456`같이 고정된 소수점의 경우, 정수 2자리, 소수 2자리만 저장할 수 있도록 설정되어 있다면 해당 수는 표현이 제한됨.
4. 실수 중에는 끝이 없는 실수 `π(3.1415926535…)`가 그러함.
5. 그렇기에 어느 지점에서는 값을 끊어야 함. 고정소수점 방식의 한계임.
6. 부동소수점은 소수점 위치를 이동시켜, 더 넓은 범위와 더 정밀한 값을 커버하기 위해 사용되는 표현 방식임.
7. 그리고 이 부동소수점의 대표격이 바로 IEEE754 방식임.
8. 자바에서 소수 표현 타입 크게 `float`와 `double`이 있음.
9. 두 타입 모두 부동소수점 방식을 사용하지만 차이점은 표현할 수 있는 크기의 차이임. 나머지는 동일함.
10. `float`은 부호(1bit) / 지수부(8bits) / 가수부(23bits)로 구성되어 있고, `double`은 부호(1bit) / 지수부(11bits) / 가수부 (52bits)로 구성되어 있음.
11. 부호는 말 그대로 +/- 부호를 나타냄. 0(양수), 1(음수)
12. 예를 들어 보겠음.
13. `12.375`라는 값이 있으면, 이것을 이진수로 변환해야 함. (변환하는 법 찾아볼 것)
14. 변환하면 1100.011(2)가 나옴.
15. 소수점을 맨 앞자리 전까지 당김. -> 1.100011(2) x 2^3
16. 여기수 지수부가 3 + Bias, 가수부가 맨 앞 1을 제외한 100011임.
17. Bias라는 값이 있음. 부동소수점 표현에서 지수부(Exponent)값을 양수로 표현하기 위한 기준값임.
18. 말이 어려움.
19. 0.00123은 -> 1.23 x 10^-3으로 표현됨
20. 컴퓨터는 음수를 좋아하지 않음. 그렇기에 지수부 값을 항상 양수로 저장하기 위해 Bias라는 기준값을 더함.
21. 컴퓨터에서 음의 정수를 표현하기 위해 보수를 고안한 것과 비슷하다고 생각하면 됨.
22. 여튼 `float`의 Bias 값은 127(2^7 - 1)이고 `double`의 Bias 값은 1023(2^10 - 1)임.
23. (참고로 `float`의 지수부 표현 범위는 8비트(-127 ~ 128)이고 `double`은 11비트(-1022 ~ 1023)임)
24. 다시 계산으로 돌아가겠음. `float` 기준임.
25. 12.375 -> 1100.011(2) -> 2^3 x 1.100011(2) -> 127 + 3 == 130 -> (지수부 130을 8비트로 표현) -> 1000 0010(2)
26. 부호(양): 0 / 지수부: 10000010(2) / 가수부: 10001100000000000000000 (나머지는 0으로 채움)
27. -> '0' '10000010' '100011'00000000000000000

## BigDecimal

1. 제네릭으로 처리하는 방법이 어려워 찾아보니, `BigDecimal`이라는 게 있음. 요놈 실행 방식이 재밌음.
2. 이 친구는 소수와 정수 모두를 저장할 수 있으며 소수 + 정수 역시 별도의 형변환 없이 저장된다고 함.
3. 보통 소수를 저장할 때는 IEEE754 부동소수점 방식으로 저장이 되어, 소수 그 자체 값이 아닌 근사치에 가까운 값이 저장됨.
4. 그러니 소수와 관련된 연산을 할 때는 상대적으로 부정확한 값이 저장될 수밖에 없는데 BigDecimal은 정확한 연산을 제공해 금융공학 같은 엄밀한 값이 보장되는 분야에서도 사용됨.
5. 연산 방법은 다음과 같음.
6. `BigDecimal num = new BigDecimal("12.5);`와 같이 문자열로 초기화.
7. 이때 초기화 값으로 문자열이 아닌 정수나 소수 자체를 입력할 수도 있는데 소수를 입력할 경우에는 부정확한 값으로 초기화될 가능성이 있음.
8. 문자열을 정수나 소수로 초기화할 때 scale를 이용해 정수부분과 가수부분을 기억.
9. 이를테면, "12.5"면 125(scale 1), "10" -> 10(scale 0)
10. 위 두 값을 더하면 123 + 10 -> 133 -> scale(1 + 0) 적용을 해서 13.3이 됨.
11. 이런 식으로 연산을 하기에 소수점 손실 없이 정확한 계산이 가능.

## BigInteger

1. 보통 `Byte`, `Short`, `Integer`, `Long` 타입들은 메모리가 한정돼, 표현할 수 있느 숫자 범위가 정해져 있음.
2. 그런데 `BigInteger`는 매우 큰 숫자도 무리 없이 다룰 수 있는데 그 이유가 필요에 따라 동적으로 할당하기 때문에 매우 큰 정수를 저장할 수 있음.
3. 즉, 저장 가능한 값의 크기는 사용 가능한 힙 메모리에 따라 결정.
4. 그러니 다른 고정된 정수 타입과 달리 `BigInteger`는 값의 크기에 제한이 없기에 정수 타입에서 볼 수 있는 정밀도 손실이나 오버플로우 문제가 없음
5. 단, 고정 크기 정수보다 연산 속도는 느림. 그러나 안정적임.

## 공변성(Covariance) & 반공변성(ContraVariance) (feat. Wildcard)
* 공변: B가 A의 하위 타입 -> B[]도 A[]의 하위 타입임.
* 반공변: B가 A의 하위 타입 -> A[]는 B[]의 하위 타입 (뭔솔?)

공변... 말이 어려움. Co-Variance의 합성어인데, Co는 '-같이'라는 의미를 지니고 있는 접두어이고, 'Variance'는 'Vary'의 명사형으로 'Vary'는 변화라는 의미를 담고 있음.
즉, Covariance는 '같은 방향으로 변화'한다는 의미이며, 반공변성은 반대로 변화한다는 의미로 받아들이면 됨.

공변과 반공변의 차이점은 '데이터 READ/WRITE' 관점에서 발생한다.
공변: 읽기(Read) 관점 / 반공변: 쓰기(WRITE) 관점
```java
Number[] numArray = new Integer[3];  // Integer는 Number의 하위 타입
numArray[0] = 1;                     // OK, Integer 값 추가 가능
Number value = numArray[0];          // OK, Number로 읽기 가능
```
반공변은 상위 타입의 배열이 하위 타입의 배열로 간주된다는 의미. 이는 상위 타입의 데이터를 하위 타입에 안전하게 쓸(WRITE) 수 있다는 의미.
단, 반공변은 자바 배열에서는 지원이 안 되고 *제네릭 와일드카드(Wildcard)에서 지원됨*
```java
List<? super Integer> list = new ArrayList<Number>();  // Number는 Integer의 상위 타입. 
// '? super Integer>'의 의미는 리스트 타입으로 Integer 혹은 Integer의 상위 타입만 올 수 있다는 의미.
list.add(10);  // OK: Integer 값을 안전하게 추가 가능. 즉 Integer 상위 타입이기만 하면 데이터 추가를 안심하고 할 수 있다.
Object value = list.get(0);  // // 읽기는 Object 타입으로만 가능 (구체적인 타입 알 수 없음). 보통 읽기는 잘 안 하고 데이터 쓸 때만 사용
```
--> 공변은 하위 타입 관계가 유지되어, 데이터를 상위 타입으로 안전하게 읽을 수 있으며, 반공변은 상위 타입 관계가 반대로 적용되어 데이터를 하위 타입에 안전하게 쓸 수 있음.

## 무공변성(Invariance)
일반적으로 제네릭은 무공변성임. 즉 타입 간 상하관계가 없음.

```java
// 즉 Integer와 Number는 상하관계지만 아래처럼 사용하면 얘기가 다름
List<Number> parent = new ArrayList<>();
List<Integer> child = new ArrayList<>();

parent = child; // !업캐스팅 불가
child = parent; // !다운캐스팅 불가
```
`Number`와 `Integer`는 상하관계지만 `List<Number>`와 `List<Integer>`는 완전히 다른 타입이며 아무런 관계도 없음.
이런 제네릭이라는 무공변성은 자바 특유의 객체 지향을 전혀 이용 못하게 함. 이를 해결하기 위한 기능, 즉 제네릭에 상하 타입 캐스팅을 가능하게 해주는 기능이 바로 위에서 언급한 `Wildcard(? extends / ? super)`임
-> Wildcard: 제네릭의 기본 속성인 무공변성 때문에 상속 관계를 활용할 수 없는 상황에서, Wildcard를 이용해 상하 관계를 활용하기 위해 사용.

* `? extends T(공변)`: T와 그 하위 타입만 허용
```java
List<? extends Number> list = new ArrayList<Integer>();  // OK
Number value = list.get(0);  // 읽기 OK
list.add(1);  // 컴파일 에러: 추가는 불가
```
* `? super T(반공변)`: T와 그 상위 타입만 허용
```java
List<? super Integer> list = new ArrayList<Number>();  // OK
list.add(10);  // 추가 OK
Object value = list.get(0);  // 읽기는 Object 타입으로 제한
```
제네릭과 공변성, 반공변성 개념은 아래 글이 훨씬 잘 작성되어 있다. (위에 글을 무시하자)

https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EC%99%80%EC%9D%BC%EB%93%9C-%EC%B9%B4%EB%93%9C-extends-super-T-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4
https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A0%9C%EB%84%A4%EB%A6%ADGenerics-%EA%B0%9C%EB%85%90-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%B3%B5%ED%95%98%EA%B8%B0


---

## 느낀점
위와 같이 글을 작성하면서, 개인적으로 TIL 같은 글을 작성함으로서 지식을 정리하는 것에 대해 의문이 들었다. 물론 잘 활용하는 사람도 있겠지만 나 같은 경우는 모르는 내용을 검색 혹은 ChatGPT를 통해 단위 시간당 빠르게 정보를 습득하는 것을 선호한다. 물론 시간이 지나면 까먹는 경우가 많겠지만 그렇다고 내가 작성한 글로 돌아갈 것 같지는 않다. 나보다 좋은 정보를 제공하는 생산자가 너무나 많기 때문에 다시 보지 않을 글을 작성하는데 조금 회의적이다.

보통 정보성 글을 작성한다고 하면, 내가 작성하고 있는 내용이 사실에 부합하는지 등을 체크를 해야 하고, 독자들을 고려해 어려운 개념을 쉽게 풀어야 한다. 물론 내가 배운 지식을 글로서 쉬운 언어로 표현한다는 점에서 유의미한 학습 효과가 있을 수도 있지만 다시 안 볼 가능성이 크다는 게 가장 디메리트한 부분이다.

위에 작성한 내용을 내가 과연 다시 볼까? 마치, '나 이만큼 공부했어요'라며 자기 만족으로 글을 썼다는 느낌을 지울 수 없다. 바로 ChatGPT와 대화를 통해 지식을 구체화하는 게 더 빠른 건 아닐까?? 